[{"content":"本文将通过几个方面来介绍插入式注解。包括如何搭建项目环境，如何编写注解处理器，以及编写 idea 插件使注解生成的代码不会报错。\n示例代码地址\n插入式注解代码地址：samples/pluggable-annotation 测试代码地址：samples/pluggable-annotation-test 插件的代码地址：samples/pluggable-annotation-idea-plugin 什么是插入式注解 JSR-269 插件化注解处理(Pluggable Annotation Processing API)\n可以在编译期期间对代码进行处理，像经常用的 lombok 也是基于这个原理，通过注解生成 getter/setter 等方法。\njavac 会通过 SPI 机制，找到要调用的注解处理器，处理完源代码后再去生成字节码。\n搭建项目环境 在编写注解处理器时，需要通过修改语法树来达成修改代码的效果，java 提供了对应的方法，但限制了访问，得自己引入。\n在 jdk8 中，可以通过引入 java安装路径/lib/tools.jar 来实现，而在 jdk8 以上的版本，已经不提供这个 tools.jar 了。那么在 jdk8 以上如何实现效果？就得自定义编译选项了，可以修改 maven 中编译插件的配置来达成目的。\n1 2 3 4 5 6 7 8 \u0026lt;compilerArgs\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;/compilerArgs\u0026gt; --add-exports 和 --add-opens （lombok 用的是这个）有细微差别，我测试了下，使用 --add-opens 会编译报错，因为我不想纠结这个事情，于是便不求甚解了。\n除此之外，还得配置一个参数：-proc:none 。这个是控制 javac 编译时的行为，-proc:none 指不使用注释处理器，只编译源文件。\nmaven 插件完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;${maven.compiler.source}\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;${maven.compiler.target}\u0026lt;/target\u0026gt; \u0026lt;compilerArgs\u0026gt; \u0026lt;arg\u0026gt;-proc:none\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;/compilerArgs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; 这里在顺手放一段 lombok 的配置：lombok/docker/maven/files/jdk-21/classpath/pom.xml\n而至于 jdk8 ，事情就简单多了，直接把 tool.jar 引入就完事了。完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.sun\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt; \u0026lt;systemPath\u0026gt;${java.home}/../lib/tools.jar\u0026lt;/systemPath\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;${maven.compiler.source}\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;${maven.compiler.target}\u0026lt;/target\u0026gt; \u0026lt;compilerArgs\u0026gt; \u0026lt;arg\u0026gt;-proc:none\u0026lt;/arg\u0026gt; \u0026lt;/compilerArgs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; ... 注解处理器编写 接下来进行代码的编写，既然是插入式注解，首先我们需要定义一个注解：\n1 2 3 4 5 6 7 8 9 10 11 package com.w2tbp.samples.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.TYPE}) @Retention(RetentionPolicy.SOURCE) public @interface MyLog { } 然后编写注解处理器，得继承 AbstractProcessor 类，并重写 process 方法。在其中我们就能够调用 java 修改语法树的一系列 api，对代码进行一顿输出。\n上一节费劲心思配置编译选项，把 tools.jar 引入，就是为了在编写注解处理器的时候调用这些 api。但关于修改语法树，也就是关于 JCTree 的一些语法，怎么使用，我就不多说了，因为我也不太了解 pwq，只是拿来用。\n我写的这个注解处理器，是为了让代码生成一段这样的代码：\nprivate final static Logger logger = LogManager.getLogger(Test.class);\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 package com.w2tbp.samples.annotation; import com.sun.tools.javac.api.JavacTrees; import com.sun.tools.javac.code.Flags; import com.sun.tools.javac.processing.JavacProcessingEnvironment; import com.sun.tools.javac.tree.JCTree; import com.sun.tools.javac.tree.TreeMaker; import com.sun.tools.javac.tree.TreeTranslator; import com.sun.tools.javac.util.*; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import javax.annotation.processing.*; import javax.lang.model.SourceVersion; import javax.lang.model.element.Element; import javax.lang.model.element.TypeElement; import java.util.Set; @SupportedAnnotationTypes(\u0026#34;com.w2tbp.samples.annotation.MyLog\u0026#34;) public class MyLogProcessor extends AbstractProcessor { private JavacTrees javacTrees; private TreeMaker treeMaker; private Names names; private static final Class\u0026lt;MyLog\u0026gt; ANNOTATION_TO_PROCESS = MyLog.class; private static final String LOG_CLASS_TYPE_NAME = Logger.class.getName(); private static final String LOG_FACTORY_CLASS_TYPE_NAME = LogManager.class.getName(); @Override public synchronized void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); this.javacTrees = JavacTrees.instance(processingEnv); Context context = ((JavacProcessingEnvironment) processingEnv).getContext(); this.treeMaker = TreeMaker.instance(context); this.names = Names.instance(context); } @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latest(); } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { JCTree.JCExpression varTypeName = strToJCExpression(LOG_CLASS_TYPE_NAME); JCTree.JCExpression varFactoryName = strToJCExpression(LOG_FACTORY_CLASS_TYPE_NAME); Name varName = names.fromString(\u0026#34;log\u0026#34;); Set\u0026lt;? extends Element\u0026gt; elements = roundEnv.getElementsAnnotatedWith(ANNOTATION_TO_PROCESS); for (Element element : elements) { String className = element.getSimpleName().toString()+\u0026#34;.class\u0026#34;; JCTree tree = javacTrees.getTree(element); tree.accept(new TreeTranslator() { @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) { JCTree.JCVariableDecl variableDecl = treeMaker.VarDef( treeMaker.Modifiers(Flags.PRIVATE + Flags.STATIC + Flags.FINAL), varName, varTypeName, treeMaker.Apply( List.nil(), treeMaker.Select( varFactoryName, names.fromString(\u0026#34;getLogger\u0026#34;) ), List.of(strToJCExpression(className)) ) ); jcClassDecl.defs = jcClassDecl.defs.prepend(variableDecl); super.visitClassDef(jcClassDecl); } }); } return true; } private JCTree.JCExpression strToJCExpression(String components) { String[] componentArray = components.split(\u0026#34;\\\\.\u0026#34;); JCTree.JCExpression expr = treeMaker.Ident(names.fromString(componentArray[0])); for (int i = 1; i \u0026lt; componentArray.length; i++) { expr = treeMaker.Select(expr, names.fromString(componentArray[i])); } return expr; } } 这样基本的事情就完事了，还剩下一件事，就是这个插入式注解得通过 SPI 的方式被编译器调用，所以需要配置一下。\n具体是在 src/main/resources/META-INF/services 目录下新建一个 javax.annotation.processing.Processor 文件\n内容为注解处理器的路径：\n1 com.w2tbp.samples.annotation.MyLogProcessor 除了这种方式，还可以用谷歌的 auto-service 依赖，然后在注解处理器上直接用注解 @AutoService 就行了。\n注解处理就告一段落了，完整代码地址在：samples/pluggable-annotation\n测试 接下来测试一下。\n新建一个项目，引入上面项目的依赖，简单写个测试类，编译后发现，我们想要的结果已经出现了：\n测试项目代码地址在：samples/pluggable-annotation-test\nidea 插件 现在我们知道可以生成语句，那么在代码中就可以用这个生成的对象了。但我们敲下 log 对象时，却出现了问题：\n这个对象飘红了，这是正常的，因为现在并没有这个对象。但是在用 lombok 的时候显然没有这个问题，这是为什么呢？因为 lombok 在 idea 中用了插件，一些较旧的 idea 版本会让人自己装，但现在都集成了。\n于是我们也来开发个自己的插件，当我们安装插件后，会看到和 lombok 一样的效果，log 也不报错了，也有代码提示了：\n关于如何写插件，新建工程，怎么配置，如何实现，说起来也有点冗杂。代码基本上就是从 lombok 插件中 copy 的，ps：看它的那个插件源代码真是一件痛苦的事情。\n插件的代码地址在：samples/pluggable-annotation-idea-plugin\n可以直接下载项目目录下的 pluggable-annotation-idea-plugin-1.0-SNAPSHOT.zip ，然后在 idea 插件选项中，选择从磁盘中安装，安装此插件。\n另需注意，IDEA 会有版本兼容问题，我这里使用的 IDEA 版本为 2024.1\n其他 报错 java: java.lang.IllegalArgumentException 路径：Build, Execution, Deployment -\u0026gt; complier -\u0026gt; Shared build process VM options\n加上该配置 -Djps.track.ap.dependencies=false\n","date":"2024-04-29T15:27:38Z","permalink":"https://w2tbp.github.io/blog/p/java-%E6%8F%92%E5%85%A5%E5%BC%8F%E6%B3%A8%E8%A7%A3/","title":"java 插入式注解"},{"content":"java stream 流处理，有点像 Linux 中的管道。\n把一个集合中的元素当做流，java 提供了一些函数去处理，上一个函数的结果输出可以当做下一个函数输入。\n寻找符合条件的元素 使用 filter\n1 2 3 4 5 6 7 8 User target1 = targetList.stream() .filter(o -\u0026gt; uid.equals(o.getId())).findAny().orElse(null); Optional\u0026lt;User\u0026gt; target2 = targetList.stream() .filter(o -\u0026gt; uid.equals(o.getId())).findAny(); Optional\u0026lt;User\u0026gt; target3 = targetList.stream() .filter(o -\u0026gt; uid.equals(o.getId())).findFirst(); findAny findFirst 都可以，视场景而定。\norElse 设定一个默认值。\n例子\n1 2 3 4 5 6 7 8 9 10 11 @Data @AllArgsConstructor public class User { private Integer id; private String name; private String country; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class StreamTest { List\u0026lt;User\u0026gt; targetList = new ArrayList\u0026lt;\u0026gt;(); public StreamTest() { User coldplay = new User(1, \u0026#34;Coldplay\u0026#34;, \u0026#34;uk\u0026#34;); User oneOkRock = new User(2, \u0026#34;OneOkRock\u0026#34;, \u0026#34;jp\u0026#34;); User queen = new User(3, \u0026#34;Queen\u0026#34;, \u0026#34;uk\u0026#34;); User mayday = new User(4, \u0026#34;Mayday\u0026#34;, \u0026#34;cn\u0026#34;); User radwimps = new User(5, \u0026#34;RADWIMPS\u0026#34;, \u0026#34;jp\u0026#34;); User supercell = new User(6, \u0026#34;Supercell\u0026#34;, \u0026#34;jp\u0026#34;); targetList.addAll(Arrays.asList(coldplay, oneOkRock, queen, mayday, radwimps, supercell)); } public static void main(String[] args) { StreamTest test = new StreamTest(); test.findOne(1); } private void findOne(Integer uid) { User target1 = targetList.stream().filter(o -\u0026gt; uid.equals(o.getId())).findAny().orElse(null); Optional\u0026lt;User\u0026gt; target2 = targetList.stream().filter(o -\u0026gt; uid.equals(o.getId())).findAny(); Optional\u0026lt;User\u0026gt; target3 = targetList.stream().filter(o -\u0026gt; uid.equals(o.getId())).findFirst(); } } 根据某个字段去重 如果是一个基础类型的集合，比如 Integer 、String 之类的，直接用 distinct() 方法就好了。但是如果是一个实体类的集合，就需要根据实体类中的某个字段来去重。\n有好几种方式，这里介绍两种。\n通过 Collectors.collectingAndThen 的 Collectors.toCollection ，里面用 TreeSet 在构造函数中指定字段 1 2 List\u0026lt;User\u0026gt; distinctList = targetList.stream() .collect(Collectors.collectingAndThen(Collectors.toCollection(() -\u0026gt; new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(o -\u0026gt; o.getCountry()))), ArrayList::new)); 使用 filter + map 1 2 3 Map\u0026lt;Object, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;User\u0026gt; distinctList = targetList.stream() .filter(i -\u0026gt; map.putIfAbsent(i.getCountry(), Boolean.TRUE) == null).collect(Collectors.toList()); 来源：List列表运用Java8的stream流按某字段去重 - cdfive - 博客园 (cnblogs.com)\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class StreamTest { List\u0026lt;User\u0026gt; targetList = new ArrayList\u0026lt;\u0026gt;(); public StreamTest() { User coldplay = new User(1, \u0026#34;Coldplay\u0026#34;, \u0026#34;uk\u0026#34;); User oneOkRock = new User(2, \u0026#34;OneOkRock\u0026#34;, \u0026#34;jp\u0026#34;); User queen = new User(3, \u0026#34;Queen\u0026#34;, \u0026#34;uk\u0026#34;); User mayday = new User(4, \u0026#34;Mayday\u0026#34;, \u0026#34;cn\u0026#34;); User radwimps = new User(5, \u0026#34;RADWIMPS\u0026#34;, \u0026#34;jp\u0026#34;); User supercell = new User(6, \u0026#34;Supercell\u0026#34;, \u0026#34;jp\u0026#34;); targetList.addAll(Arrays.asList(coldplay, oneOkRock, queen, mayday, radwimps, supercell)); } public static void main(String[] args) { StreamTest test = new StreamTest(); test.distinct1(); test.distinct2(); } private void distinct1() { List\u0026lt;User\u0026gt; distinctList = targetList.stream() .collect(Collectors.collectingAndThen(Collectors.toCollection(() -\u0026gt; new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(o -\u0026gt; o.getCountry()))), ArrayList::new)); System.out.println(distinctList); } private void distinct2() { Map\u0026lt;Object, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;User\u0026gt; distinctList = targetList.stream() .filter(i -\u0026gt; map.putIfAbsent(i.getCountry(), Boolean.TRUE) == null).collect(Collectors.toList()); System.out.println(distinctList); } } 排序 可以使用提供的一系列方法，例如 Comparator.comparingInt() 之类的。\n也可以自定义一个 Comparator\n1 2 3 4 5 Comparator\u0026lt;User\u0026gt; comparator = (o1, o2) -\u0026gt; { // 可添加更多的条件 return o1.getId() - o2.getId(); }; targetList = targetList.stream().sorted(comparator).collect(Collectors.toList()); java8 stream多字段排序 - SugarWater - 博客园 (cnblogs.com)\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class StreamTest { List\u0026lt;User\u0026gt; targetList = new ArrayList\u0026lt;\u0026gt;(); public StreamTest() { User coldplay = new User(1, \u0026#34;Coldplay\u0026#34;, \u0026#34;uk\u0026#34;); User oneOkRock = new User(2, \u0026#34;OneOkRock\u0026#34;, \u0026#34;jp\u0026#34;); User queen = new User(3, \u0026#34;Queen\u0026#34;, \u0026#34;uk\u0026#34;); User mayday = new User(4, \u0026#34;Mayday\u0026#34;, \u0026#34;cn\u0026#34;); User radwimps = new User(5, \u0026#34;RADWIMPS\u0026#34;, \u0026#34;jp\u0026#34;); User supercell = new User(6, \u0026#34;Supercell\u0026#34;, \u0026#34;jp\u0026#34;); targetList.addAll(Arrays.asList(radwimps, mayday, coldplay, queen, supercell, oneOkRock)); } public static void main(String[] args) { StreamTest test = new StreamTest(); test.sort(); } private void sort() { System.out.println(targetList); Comparator\u0026lt;User\u0026gt; comparator = (o1, o2) -\u0026gt; { // 可添加更多的条件 return o1.getId() - o2.getId(); }; targetList = targetList.stream().sorted(comparator).collect(Collectors.toList()); System.out.println(targetList); targetList = targetList.stream().sorted(Comparator.comparing(User::getCountry)).collect(Collectors.toList()); System.out.println(targetList); } } 分组 1 2 Map\u0026lt;String, List\u0026lt;User\u0026gt;\u0026gt; map = targetList.stream() .collect(Collectors.groupingBy(User::getCountry)); Java8 Stream之group - 简书 (jianshu.com)\n例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class StreamTest { List\u0026lt;User\u0026gt; targetList = new ArrayList\u0026lt;\u0026gt;(); public StreamTest() { User coldplay = new User(1, \u0026#34;Coldplay\u0026#34;, \u0026#34;uk\u0026#34;); User oneOkRock = new User(2, \u0026#34;OneOkRock\u0026#34;, \u0026#34;jp\u0026#34;); User queen = new User(3, \u0026#34;Queen\u0026#34;, \u0026#34;uk\u0026#34;); User mayday = new User(4, \u0026#34;Mayday\u0026#34;, \u0026#34;cn\u0026#34;); User radwimps = new User(5, \u0026#34;RADWIMPS\u0026#34;, \u0026#34;jp\u0026#34;); User supercell = new User(6, \u0026#34;Supercell\u0026#34;, \u0026#34;jp\u0026#34;); targetList.addAll(Arrays.asList(radwimps, mayday, coldplay, queen, supercell, oneOkRock)); } public static void main(String[] args) { StreamTest test = new StreamTest(); test.groupBy(); } private void groupBy() { Map\u0026lt;String, List\u0026lt;User\u0026gt;\u0026gt; map = targetList.stream() .collect(Collectors.groupingBy(User::getCountry)); System.out.println(map); } } 截取某个字段 在只需要实体类的某一个字段时比较好用，可以在后面再加个 distinct() 去重\n1 List\u0026lt;String\u0026gt; mapping = targetList.stream().map(User::getCountry).collect(Collectors.toList()); 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class StreamTest { List\u0026lt;User\u0026gt; targetList = new ArrayList\u0026lt;\u0026gt;(); public StreamTest() { User coldplay = new User(1, \u0026#34;Coldplay\u0026#34;, \u0026#34;uk\u0026#34;); User oneOkRock = new User(2, \u0026#34;OneOkRock\u0026#34;, \u0026#34;jp\u0026#34;); User queen = new User(3, \u0026#34;Queen\u0026#34;, \u0026#34;uk\u0026#34;); User mayday = new User(4, \u0026#34;Mayday\u0026#34;, \u0026#34;cn\u0026#34;); User radwimps = new User(5, \u0026#34;RADWIMPS\u0026#34;, \u0026#34;jp\u0026#34;); User supercell = new User(6, \u0026#34;Supercell\u0026#34;, \u0026#34;jp\u0026#34;); targetList.addAll(Arrays.asList(radwimps, mayday, coldplay, queen, supercell, oneOkRock)); } public static void main(String[] args) { StreamTest test = new StreamTest(); test.mapping(); } private void mapping() { List\u0026lt;String\u0026gt; mapping = targetList.stream().map(User::getCountry).collect(Collectors.toList()); System.out.println(mapping); List\u0026lt;String\u0026gt; mapping2 = targetList.stream().map(User::getCountry).distinct().collect(Collectors.toList()); System.out.println(mapping2); } } 完整示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class StreamTest { List\u0026lt;User\u0026gt; targetList = new ArrayList\u0026lt;\u0026gt;(); public StreamTest() { User coldplay = new User(1, \u0026#34;Coldplay\u0026#34;, \u0026#34;uk\u0026#34;); User oneOkRock = new User(2, \u0026#34;OneOkRock\u0026#34;, \u0026#34;jp\u0026#34;); User queen = new User(3, \u0026#34;Queen\u0026#34;, \u0026#34;uk\u0026#34;); User mayday = new User(4, \u0026#34;Mayday\u0026#34;, \u0026#34;cn\u0026#34;); User radwimps = new User(5, \u0026#34;RADWIMPS\u0026#34;, \u0026#34;jp\u0026#34;); User supercell = new User(6, \u0026#34;Supercell\u0026#34;, \u0026#34;jp\u0026#34;); targetList.addAll(Arrays.asList(radwimps, mayday, coldplay, queen, supercell, oneOkRock)); } public static void main(String[] args) { StreamTest test = new StreamTest(); test.findOne(1); test.distinct1(); test.distinct2(); test.sort(); test.groupBy(); test.mapping(); } private void mapping() { List\u0026lt;String\u0026gt; mapping = targetList.stream().map(User::getCountry).collect(Collectors.toList()); System.out.println(mapping); List\u0026lt;String\u0026gt; mapping2 = targetList.stream().map(User::getCountry).distinct().collect(Collectors.toList()); System.out.println(mapping2); } private void groupBy() { Map\u0026lt;String, List\u0026lt;User\u0026gt;\u0026gt; map = targetList.stream() .collect(Collectors.groupingBy(User::getCountry)); System.out.println(map); } private void sort() { System.out.println(targetList); Comparator\u0026lt;User\u0026gt; comparator = (o1, o2) -\u0026gt; { // 可添加更多的条件 return o1.getId() - o2.getId(); }; targetList = targetList.stream().sorted(comparator).collect(Collectors.toList()); System.out.println(targetList); targetList = targetList.stream().sorted(Comparator.comparing(User::getCountry)).collect(Collectors.toList()); System.out.println(targetList); } private void distinct1() { List\u0026lt;User\u0026gt; distinctList = targetList.stream() .collect(Collectors.collectingAndThen(Collectors.toCollection(() -\u0026gt; new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(o -\u0026gt; o.getCountry()))), ArrayList::new)); System.out.println(distinctList); } private void distinct2() { Map\u0026lt;Object, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;User\u0026gt; distinctList = targetList.stream() .filter(i -\u0026gt; map.putIfAbsent(i.getCountry(), Boolean.TRUE) == null).collect(Collectors.toList()); System.out.println(distinctList); } private void findOne(Integer uid) { User target1 = targetList.stream() .filter(o -\u0026gt; uid.equals(o.getId())).findAny().orElse(null); Optional\u0026lt;User\u0026gt; target2 = targetList.stream() .filter(o -\u0026gt; uid.equals(o.getId())).findAny(); Optional\u0026lt;User\u0026gt; target3 = targetList.stream() .filter(o -\u0026gt; uid.equals(o.getId())).findFirst(); } } 用这个东西得发挥想象力，然后有时候会发现\u0026hellip;\nfor 其实挺好用的。\n","date":"2023-07-27T20:01:24Z","permalink":"https://w2tbp.github.io/blog/p/java-stream-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","title":"java stream 的一些使用心得"},{"content":"hugo 之前用的是 hexo ，最近发现了 hugo ，感觉还行，就拿来玩玩。 跟 hexo 一样，都是生成静态页面的。\n下载 去 github 上下载一下就完事了：gohugoio/hugo: The world’s fastest framework for building websites. (github.com)\n这里还有个小坑，这东西的 release 有两个版本，要下那个带 extended 的那个。\n因为我是在 windows 平台，下载 windows-amd64 的就可以了。\n环境变量 需要把解压出来的 exe 文件放到 bin 文件夹下，然后加到环境变量里。\n例如，我新建了一个 D:\\hugo\\bin 文件夹，然后把解压出来的 hugo.exe 放到此文件夹。接着在系统环境变量 path 里，加入 D:\\hugo\\bin 。\n可以在 cmd 中输入 hugo server 看看是否添加好了\n主题美化 Complete List | Hugo Themes (gohugo.io)\n去上面这个网站找了找，试了几个，发现有个叫 stack 的还不错，搜了搜发现了作者提供的一个模版：CaiJimmy/hugo-theme-stack-starter\n作者还写好了 Github Actions ，只需要提交就好了，so sweet。\ngithub page hugo 只负责生成静态页面，还需要把这些页面托管方便访问，github page 就是一个很好的选择。\n我之前用的是 hexo ，所以是建了一个 username.github.io 的库，然后往里面推就完事了。\n而stack-starter 这个项目是把静态页面推到了一个 gh-pages 的分支里。 所以需要更改 github page 的设置，位于 Settings -\u0026gt; pages 然后更改 Branch\n当然默认模版会有很多东西想要个性化，比如页底、外链。这些就去查文档后配置吧。 Stack | Card-style Hugo theme designed for bloggers (jimmycai.com)\n忽略渲染 hugo 可以配置忽略渲染某些文件\n使用 hugo 编译时，将忽略 config.toml 文件中指定的内容，比如：以 .foo 和 .boo 结尾的文件。\n1 ignoreFiles = [ \u0026#34;\\\\.foo$\u0026#34;, \u0026#34;\\\\.boo$\u0026#34; ] 上面使用了正则表达式，使用 \\ 转义是因为在 TOML 里。\n配置 Hugo - Hugo中文文档 (gohugo.org)\nobsidian obsidian 很好用，拿来写 md ，hugo 用来生成页面，强强联合，完美。\n但是用 obsidian 还有一些问题，好在插件生态很丰富。\n插入图片重命名 obsidian 原生插入图片时，有一些问题。\n原生的插入图片，默认会是双链，而不是 md 格式的 ![]() 。需要在设置 -\u0026gt; 文件与链接 -\u0026gt; 关闭 使用 WiKi 链接。\n还有原生的会自己生成一个文件名，例如 Pasted image 20230726205233.png 这个空格就很烦，hugo 不知道为什么不会渲染。所以需要一个更改文件名的插件，我使用了 paste-image-rename\nreorx/obsidian-paste-image-rename\n流程图 使用大家都用的 excalidraw ，然后导出图片到再插入到 md 中就行了。\n不知道为什么 excalidraw 好像不会渲染，如果会渲染就在配置文件中忽略就好。\nmarkdown 换行 obsidian 如果只回车一次，在页面上是不会渲染成换行的，这跟 md 的语法有关 Markdown 换行语法\n所以要么就回车两次，要么就在需要换行的段落后面加俩空格。\n","date":"2023-07-19T22:07:13Z","permalink":"https://w2tbp.github.io/blog/p/%E4%BD%BF%E7%94%A8-hugo--obsidian-%E6%9D%A5%E5%86%99%E5%8D%9A%E5%AE%A2/","title":"使用 hugo + obsidian 来写博客"},{"content":"一个可以用在不同设备之间，同步文件的工具。这篇文章主要讲讲在各平台如何安装。\n为了同步的稳定，需要一个24小时在线的机器，我这里使用了云服务器，如果你没有，可以去看看微力同步。\n以下链接大致介绍了下怎么用： https://zhuanlan.zhihu.com/p/69267020\nwindow下安装 有客户端版本的，由社区维护，我下下来试了下，没有跟到最新版本，看其他文章好像有 bug ，而且大佬也给出了其他的方案。\n也就是开机自启一个 bat 文件，启动 Syncthing 提供的命令行工具。\n先去官网下个包 https://syncthing.net/downloads/\n然后 win + r 输入 shell:startup ，在其中新建一个 bat 文件（可以先新建个 txt 文件，输入下面内容后，再将 txt 后缀改为 bat）\n需要修改三个地方\nD:\\software\\syncthing-windows-amd64-v1.22.0\\syncthing.exe 程序的目录。\n-config=\u0026quot;C:\\Users\\admin\\AppData\\Local\\Syncthing\u0026quot; Syncthing的配置目录。得先运行一下安装包的 syncthing.exe 才会出现，下面那个也一样\n-data=\u0026quot;C:\\Users\\admin\\AppData\\Local\\Syncthing\\index-v0.14.0.db\u0026quot; 1 2 3 @ECHO OFF %1 start mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;\u0026#34;\u0026#34;%~0\u0026#34;\u0026#34; ::\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit start /b D:\\software\\syncthing-windows-amd64-v1.22.0\\syncthing.exe -config=\u0026#34;C:\\Users\\admin\\AppData\\Local\\Syncthing\u0026#34; -data=\u0026#34;C:\\Users\\admin\\AppData\\Local\\Syncthing\\index-v0.14.0.db\u0026#34; -no-browser 程序运行后，访问 http://127.0.0.1:8384/ 可以进入管理页面\n参考链接\nhttps://blog.csdn.net/rockage/article/details/121079720\nubuntu 下安装 同步服务，就需要一个24小时在线的服务器。我用的是腾讯云的，系统是 Ubuntu Server 20.04 LTS\n1 2 3 4 5 6 7 8 9 10 11 12 # Add the release PGP keys: sudo curl -o /usr/share/keyrings/syncthing-archive-keyring.gpg https://syncthing.net/release-key.gpg # Add the \u0026#34;stable\u0026#34; channel to your APT sources: echo \u0026#34;deb [signed-by=/usr/share/keyrings/syncthing-archive-keyring.gpg] https://apt.syncthing.net/ syncthing stable\u0026#34; | sudo tee /etc/apt/sources.list.d/syncthing.list # Update and install syncthing: sudo apt-get update sudo apt-get install syncthing # check version syncthing --version 上面安装好了，但是会有个问题，这玩意的 webui 不能用服务器的公网 ip 访问，只能用 http://127.0.0.1:8384/ 访问。应该可以用 nginx 的反向代理解决，我太菜了配置半天没成，然后发现了另外一种方法。\n以下来源参考链接1\n自 Ubuntu 18.04+ 开始，就可以通过创建 systemd 配置文件来管理 syncthing 服务。官方也提供了配置文件：etc/linux-systemd\n首先先创建个文件\nsudo vim /etc/systemd/system/syncthing@.service\n然后输入以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Unit] Description=Syncthing - Open Source Continuous File Synchronization for %I Documentation=man:syncthing(1) After=network.target [Service] User=%i ExecStart=/usr/bin/syncthing -no-browser -gui-address=\u0026#34;0.0.0.0:8384\u0026#34; -no-restart -logflags=0 Restart=on-failure SuccessExitStatus=3 4 RestartForceExitStatus=3 4 [Install] WantedBy=multi-user.target 这样，你就能用腾讯云给的 ip 来访问了，当然防火墙得开 8384 。\n注意：并且需要开 22000 端口，不然添加不了远程设备（我被坑半天）\n然后可以配置一下 systemd\n1 2 3 4 5 6 7 8 9 10 # 更新 systemd 服务 sudo systemctl daemon-reload # 启动 syncthing 服务 sudo systemctl start syncthing@$USER # 开启自启 sudo systemctl enable syncthing@$USER # 查看服务状态 systemctl status syncthing@$USER 参考链接\nhttps://computingforgeeks.com/how-to-install-and-use-syncthing-on-ubuntu/ https://apt.syncthing.net/ 安卓 安卓手机端同步目录提示 错误 (folder marker missing)\n这是由于该同步目录下面缺少一个 .stfolder 目录，解决办法是在该目录下新建文件夹: .stfolder (注意前面的 \u0026ldquo;.\u0026quot;)，因为该文件夹为隐藏文件夹，有的国内定制安卓系统或者系统清理软件会自动清除该文件夹，所以如果新建 .stfolder 文件夹后还出现这样的情况，可以在 .stfolder 里随便新建一个空文件，比如我就在该文件夹下新建一个名为 .stfolder 的空文件。\nhttps://zhuanlan.zhihu.com/p/121544814\n","date":"2023-07-16T21:06:38Z","permalink":"https://w2tbp.github.io/blog/p/%E4%BD%BF%E7%94%A8-syncthing-%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6/","title":"使用 Syncthing 同步文件"},{"content":"在导航栏中使用 uniapp 的导航栏，如果想要添加图标就得在 page.json 页面配置，因为自定义 button 只支持字体图标，所以想到了 fontawesome\npage.json - style\n首先下载 fontawesome ，去官网\n点击下载旧版 v4.7 ，解压后找到 /fonts/fontawesome-webfont.ttf ，复制粘贴到 uniapp 项目中，我这里放在了 static 目录下\n因为 fontSrc 中只能填写 unicode ，所以需要填入图标的 unicode，这个可以在 cheatsheet 找到\n例如这个右箭头，就是 f061\npage.json 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ... \u0026#34;path\u0026#34;: \u0026#34;pages/index/index\u0026#34;, \u0026#34;style\u0026#34;: { \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;uni-app\u0026#34;, \u0026#34;app-plus\u0026#34;: { \u0026#34;bounce\u0026#34;: \u0026#34;vertical\u0026#34;, \u0026#34;titleNView\u0026#34;: { \u0026#34;titleAlign\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;subtitleText\u0026#34;: \u0026#34;uni-app.com\u0026#34;, \u0026#34;buttons\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;\\uf061\u0026#34;, \u0026#34;fontSrc\u0026#34;: \u0026#34;/static/fontawesome-webfont.ttf\u0026#34;, \u0026#34;fontSize\u0026#34;: \u0026#34;22px\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFFFF\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;\\uf062\u0026#34;, \u0026#34;fontSrc\u0026#34;: \u0026#34;/static/fontawesome-webfont.ttf\u0026#34;, \u0026#34;fontSize\u0026#34;: \u0026#34;22px\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FFFFFF\u0026#34; }] } } } ... 最终效果\n参考链接\nFont Awesome字体图标如何使用？\n在页面上使用 我们需要两个东西，一个是 ttf 文件，一个是 css 文件\nttf 跟上面的一样，是 /fonts/fontawesome-webfont.ttf\ncss 是 /css/font-awesome.min.css\n将这两个文件复制到项目中，我这里还是放在 static 目录下\n好像在微信小程序中使用还得将 ttf 文件转成 Base64 ，我这边只需要关心 app ，好像也不用转。\n链接 uniapp引入 FontAwesome 中有转 Base64 的方法\n接下来需要修改 css 文件，替换 @font-face 里面的内容，修改为 ttf 文件在项目中的路径。\n然后在 App.vue 文件中全局引入 css 文件\n然后就可以使用了\n参考链接\nuniapp引入 FontAwesome\n","date":"2022-06-30T15:39:16Z","permalink":"https://w2tbp.github.io/blog/p/%E5%9C%A8-uniapp-%E4%B8%AD%E4%BD%BF%E7%94%A8-fontawesome/","title":"在 uniapp 中使用 fontawesome"},{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://docs.stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://w2tbp.github.io/blog/p/hello-world/cover_hu6307248181568134095.jpg","permalink":"https://w2tbp.github.io/blog/p/hello-world/","title":"Hello World"}]